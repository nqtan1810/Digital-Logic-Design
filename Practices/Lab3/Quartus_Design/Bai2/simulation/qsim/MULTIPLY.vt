// Copyright (C) 1991-2013 Altera Corporation
// Your use of Altera Corporation's design tools, logic functions 
// and other software and tools, and its AMPP partner logic 
// functions, and any output files from any of the foregoing 
// (including device programming or simulation files), and any 
// associated documentation or information are expressly subject 
// to the terms and conditions of the Altera Program License 
// Subscription Agreement, Altera MegaCore Function License 
// Agreement, or other applicable license agreement, including, 
// without limitation, that your use is for the sole purpose of 
// programming logic devices manufactured by Altera and sold by 
// Altera or its authorized distributors.  Please refer to the 
// applicable agreement for further details.

// *****************************************************************************
// This file contains a Verilog test bench with test vectors .The test vectors  
// are exported from a vector file in the Quartus Waveform Editor and apply to  
// the top level entity of the current Quartus project .The user can use this   
// testbench to simulate his design using a third-party simulation tool .       
// *****************************************************************************
// Generated on "05/23/2023 17:19:10"
                                                                        
// Verilog Self-Checking Test Bench (with test vectors) for design :    TOP
// 
// Simulation tool : 3rd Party
// 

`timescale 1 ps/ 1 ps
module TOP_vlg_sample_tst(
	A,
	B,
	CLK,
	SEL,
	sampler_tx
);
input [3:0] A;
input [3:0] B;
input  CLK;
input  SEL;
output sampler_tx;

reg sample;
time current_time;
always @(A or B or CLK or SEL)
                                                                                
begin                                                 
 if ($realtime > 0)                                   
 begin                                                
	if ($realtime == 0 || $realtime != current_time)  
	begin									          
		if (sample === 1'bx)                          
			sample = 0;                               
		else                                          
			sample = ~sample;                         
	end										          
	current_time = $realtime;					      
 end                                                  
end                                                   

assign sampler_tx = sample;
endmodule

module TOP_vlg_check_tst (
	AA,
	AB,
	AC,
	AD,
	AE,
	AF,
	AG,
	BA,
	BB,
	BC,
	BD,
	BE,
	BF,
	BG,
	OUT,
	sampler_rx
);
input  AA;
input  AB;
input  AC;
input  AD;
input  AE;
input  AF;
input  AG;
input  BA;
input  BB;
input  BC;
input  BD;
input  BE;
input  BF;
input  BG;
input [7:0] OUT;
input sampler_rx;

reg  AA_expected;
reg  AB_expected;
reg  AC_expected;
reg  AD_expected;
reg  AE_expected;
reg  AF_expected;
reg  AG_expected;
reg  BA_expected;
reg  BB_expected;
reg  BC_expected;
reg  BD_expected;
reg  BE_expected;
reg  BF_expected;
reg  BG_expected;
reg [7:0] OUT_expected;

reg  AA_prev;
reg  AB_prev;
reg  AC_prev;
reg  AD_prev;
reg  AE_prev;
reg  AF_prev;
reg  AG_prev;
reg  BA_prev;
reg  BB_prev;
reg  BC_prev;
reg  BD_prev;
reg  BE_prev;
reg  BF_prev;
reg  BG_prev;
reg [7:0] OUT_prev;

reg  AA_expected_prev;
reg  AB_expected_prev;
reg  AC_expected_prev;
reg  AD_expected_prev;
reg  AE_expected_prev;
reg  AF_expected_prev;
reg  AG_expected_prev;
reg  BA_expected_prev;
reg  BB_expected_prev;
reg  BC_expected_prev;
reg  BD_expected_prev;
reg  BE_expected_prev;
reg  BF_expected_prev;
reg  BG_expected_prev;
reg [7:0] OUT_expected_prev;

reg  last_AA_exp;
reg  last_AB_exp;
reg  last_AC_exp;
reg  last_AD_exp;
reg  last_AE_exp;
reg  last_AF_exp;
reg  last_AG_exp;
reg  last_BA_exp;
reg  last_BB_exp;
reg  last_BC_exp;
reg  last_BD_exp;
reg  last_BE_exp;
reg  last_BF_exp;
reg  last_BG_exp;
reg [7:0] last_OUT_exp;

reg trigger;

integer i;
integer nummismatches;

reg [1:15] on_first_change ;


initial
begin
trigger = 0;
i = 0;
nummismatches = 0;
on_first_change = 15'b1;
end

// update real /o prevs

always @(trigger)
begin
	AA_prev = AA;
	AB_prev = AB;
	AC_prev = AC;
	AD_prev = AD;
	AE_prev = AE;
	AF_prev = AF;
	AG_prev = AG;
	BA_prev = BA;
	BB_prev = BB;
	BC_prev = BC;
	BD_prev = BD;
	BE_prev = BE;
	BF_prev = BF;
	BG_prev = BG;
	OUT_prev = OUT;
end

// update expected /o prevs

always @(trigger)
begin
	AA_expected_prev = AA_expected;
	AB_expected_prev = AB_expected;
	AC_expected_prev = AC_expected;
	AD_expected_prev = AD_expected;
	AE_expected_prev = AE_expected;
	AF_expected_prev = AF_expected;
	AG_expected_prev = AG_expected;
	BA_expected_prev = BA_expected;
	BB_expected_prev = BB_expected;
	BC_expected_prev = BC_expected;
	BD_expected_prev = BD_expected;
	BE_expected_prev = BE_expected;
	BF_expected_prev = BF_expected;
	BG_expected_prev = BG_expected;
	OUT_expected_prev = OUT_expected;
end



// expected AA
initial
begin
	AA_expected = 1'bX;
end 

// expected AB
initial
begin
	AB_expected = 1'bX;
end 

// expected AC
initial
begin
	AC_expected = 1'bX;
end 

// expected AD
initial
begin
	AD_expected = 1'bX;
end 

// expected AE
initial
begin
	AE_expected = 1'bX;
end 

// expected AF
initial
begin
	AF_expected = 1'bX;
end 

// expected AG
initial
begin
	AG_expected = 1'bX;
end 

// expected BA
initial
begin
	BA_expected = 1'bX;
end 

// expected BB
initial
begin
	BB_expected = 1'bX;
end 

// expected BC
initial
begin
	BC_expected = 1'bX;
end 

// expected BD
initial
begin
	BD_expected = 1'bX;
end 

// expected BE
initial
begin
	BE_expected = 1'bX;
end 

// expected BF
initial
begin
	BF_expected = 1'bX;
end 

// expected BG
initial
begin
	BG_expected = 1'bX;
end 
// expected OUT[ 7 ]
initial
begin
	OUT_expected[7] = 1'bX;
end 
// expected OUT[ 6 ]
initial
begin
	OUT_expected[6] = 1'bX;
end 
// expected OUT[ 5 ]
initial
begin
	OUT_expected[5] = 1'bX;
end 
// expected OUT[ 4 ]
initial
begin
	OUT_expected[4] = 1'bX;
end 
// expected OUT[ 3 ]
initial
begin
	OUT_expected[3] = 1'bX;
end 
// expected OUT[ 2 ]
initial
begin
	OUT_expected[2] = 1'bX;
end 
// expected OUT[ 1 ]
initial
begin
	OUT_expected[1] = 1'bX;
end 
// expected OUT[ 0 ]
initial
begin
	OUT_expected[0] = 1'bX;
end 
// generate trigger
always @(AA_expected or AA or AB_expected or AB or AC_expected or AC or AD_expected or AD or AE_expected or AE or AF_expected or AF or AG_expected or AG or BA_expected or BA or BB_expected or BB or BC_expected or BC or BD_expected or BD or BE_expected or BE or BF_expected or BF or BG_expected or BG or OUT_expected or OUT)
begin
	trigger <= ~trigger;
end

always @(posedge sampler_rx or negedge sampler_rx)
begin
`ifdef debug_tbench
	$display("Scanning pattern %d @time = %t",i,$realtime );
	i = i + 1;
	$display("| expected AA = %b | expected AB = %b | expected AC = %b | expected AD = %b | expected AE = %b | expected AF = %b | expected AG = %b | expected BA = %b | expected BB = %b | expected BC = %b | expected BD = %b | expected BE = %b | expected BF = %b | expected BG = %b | expected OUT = %b | ",AA_expected_prev,AB_expected_prev,AC_expected_prev,AD_expected_prev,AE_expected_prev,AF_expected_prev,AG_expected_prev,BA_expected_prev,BB_expected_prev,BC_expected_prev,BD_expected_prev,BE_expected_prev,BF_expected_prev,BG_expected_prev,OUT_expected_prev);
	$display("| real AA = %b | real AB = %b | real AC = %b | real AD = %b | real AE = %b | real AF = %b | real AG = %b | real BA = %b | real BB = %b | real BC = %b | real BD = %b | real BE = %b | real BF = %b | real BG = %b | real OUT = %b | ",AA_prev,AB_prev,AC_prev,AD_prev,AE_prev,AF_prev,AG_prev,BA_prev,BB_prev,BC_prev,BD_prev,BE_prev,BF_prev,BG_prev,OUT_prev);
`endif
	if (
		( AA_expected_prev !== 1'bx ) && ( AA_prev !== AA_expected_prev )
		&& ((AA_expected_prev !== last_AA_exp) ||
			on_first_change[1])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port AA :: @time = %t",  $realtime);
		$display ("     Expected value = %b", AA_expected_prev);
		$display ("     Real value = %b", AA_prev);
		nummismatches = nummismatches + 1;
		on_first_change[1] = 1'b0;
		last_AA_exp = AA_expected_prev;
	end
	if (
		( AB_expected_prev !== 1'bx ) && ( AB_prev !== AB_expected_prev )
		&& ((AB_expected_prev !== last_AB_exp) ||
			on_first_change[2])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port AB :: @time = %t",  $realtime);
		$display ("     Expected value = %b", AB_expected_prev);
		$display ("     Real value = %b", AB_prev);
		nummismatches = nummismatches + 1;
		on_first_change[2] = 1'b0;
		last_AB_exp = AB_expected_prev;
	end
	if (
		( AC_expected_prev !== 1'bx ) && ( AC_prev !== AC_expected_prev )
		&& ((AC_expected_prev !== last_AC_exp) ||
			on_first_change[3])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port AC :: @time = %t",  $realtime);
		$display ("     Expected value = %b", AC_expected_prev);
		$display ("     Real value = %b", AC_prev);
		nummismatches = nummismatches + 1;
		on_first_change[3] = 1'b0;
		last_AC_exp = AC_expected_prev;
	end
	if (
		( AD_expected_prev !== 1'bx ) && ( AD_prev !== AD_expected_prev )
		&& ((AD_expected_prev !== last_AD_exp) ||
			on_first_change[4])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port AD :: @time = %t",  $realtime);
		$display ("     Expected value = %b", AD_expected_prev);
		$display ("     Real value = %b", AD_prev);
		nummismatches = nummismatches + 1;
		on_first_change[4] = 1'b0;
		last_AD_exp = AD_expected_prev;
	end
	if (
		( AE_expected_prev !== 1'bx ) && ( AE_prev !== AE_expected_prev )
		&& ((AE_expected_prev !== last_AE_exp) ||
			on_first_change[5])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port AE :: @time = %t",  $realtime);
		$display ("     Expected value = %b", AE_expected_prev);
		$display ("     Real value = %b", AE_prev);
		nummismatches = nummismatches + 1;
		on_first_change[5] = 1'b0;
		last_AE_exp = AE_expected_prev;
	end
	if (
		( AF_expected_prev !== 1'bx ) && ( AF_prev !== AF_expected_prev )
		&& ((AF_expected_prev !== last_AF_exp) ||
			on_first_change[6])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port AF :: @time = %t",  $realtime);
		$display ("     Expected value = %b", AF_expected_prev);
		$display ("     Real value = %b", AF_prev);
		nummismatches = nummismatches + 1;
		on_first_change[6] = 1'b0;
		last_AF_exp = AF_expected_prev;
	end
	if (
		( AG_expected_prev !== 1'bx ) && ( AG_prev !== AG_expected_prev )
		&& ((AG_expected_prev !== last_AG_exp) ||
			on_first_change[7])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port AG :: @time = %t",  $realtime);
		$display ("     Expected value = %b", AG_expected_prev);
		$display ("     Real value = %b", AG_prev);
		nummismatches = nummismatches + 1;
		on_first_change[7] = 1'b0;
		last_AG_exp = AG_expected_prev;
	end
	if (
		( BA_expected_prev !== 1'bx ) && ( BA_prev !== BA_expected_prev )
		&& ((BA_expected_prev !== last_BA_exp) ||
			on_first_change[8])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port BA :: @time = %t",  $realtime);
		$display ("     Expected value = %b", BA_expected_prev);
		$display ("     Real value = %b", BA_prev);
		nummismatches = nummismatches + 1;
		on_first_change[8] = 1'b0;
		last_BA_exp = BA_expected_prev;
	end
	if (
		( BB_expected_prev !== 1'bx ) && ( BB_prev !== BB_expected_prev )
		&& ((BB_expected_prev !== last_BB_exp) ||
			on_first_change[9])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port BB :: @time = %t",  $realtime);
		$display ("     Expected value = %b", BB_expected_prev);
		$display ("     Real value = %b", BB_prev);
		nummismatches = nummismatches + 1;
		on_first_change[9] = 1'b0;
		last_BB_exp = BB_expected_prev;
	end
	if (
		( BC_expected_prev !== 1'bx ) && ( BC_prev !== BC_expected_prev )
		&& ((BC_expected_prev !== last_BC_exp) ||
			on_first_change[10])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port BC :: @time = %t",  $realtime);
		$display ("     Expected value = %b", BC_expected_prev);
		$display ("     Real value = %b", BC_prev);
		nummismatches = nummismatches + 1;
		on_first_change[10] = 1'b0;
		last_BC_exp = BC_expected_prev;
	end
	if (
		( BD_expected_prev !== 1'bx ) && ( BD_prev !== BD_expected_prev )
		&& ((BD_expected_prev !== last_BD_exp) ||
			on_first_change[11])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port BD :: @time = %t",  $realtime);
		$display ("     Expected value = %b", BD_expected_prev);
		$display ("     Real value = %b", BD_prev);
		nummismatches = nummismatches + 1;
		on_first_change[11] = 1'b0;
		last_BD_exp = BD_expected_prev;
	end
	if (
		( BE_expected_prev !== 1'bx ) && ( BE_prev !== BE_expected_prev )
		&& ((BE_expected_prev !== last_BE_exp) ||
			on_first_change[12])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port BE :: @time = %t",  $realtime);
		$display ("     Expected value = %b", BE_expected_prev);
		$display ("     Real value = %b", BE_prev);
		nummismatches = nummismatches + 1;
		on_first_change[12] = 1'b0;
		last_BE_exp = BE_expected_prev;
	end
	if (
		( BF_expected_prev !== 1'bx ) && ( BF_prev !== BF_expected_prev )
		&& ((BF_expected_prev !== last_BF_exp) ||
			on_first_change[13])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port BF :: @time = %t",  $realtime);
		$display ("     Expected value = %b", BF_expected_prev);
		$display ("     Real value = %b", BF_prev);
		nummismatches = nummismatches + 1;
		on_first_change[13] = 1'b0;
		last_BF_exp = BF_expected_prev;
	end
	if (
		( BG_expected_prev !== 1'bx ) && ( BG_prev !== BG_expected_prev )
		&& ((BG_expected_prev !== last_BG_exp) ||
			on_first_change[14])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port BG :: @time = %t",  $realtime);
		$display ("     Expected value = %b", BG_expected_prev);
		$display ("     Real value = %b", BG_prev);
		nummismatches = nummismatches + 1;
		on_first_change[14] = 1'b0;
		last_BG_exp = BG_expected_prev;
	end
	if (
		( OUT_expected_prev[0] !== 1'bx ) && ( OUT_prev[0] !== OUT_expected_prev[0] )
		&& ((OUT_expected_prev[0] !== last_OUT_exp[0]) ||
			on_first_change[15])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port OUT[0] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", OUT_expected_prev);
		$display ("     Real value = %b", OUT_prev);
		nummismatches = nummismatches + 1;
		on_first_change[15] = 1'b0;
		last_OUT_exp[0] = OUT_expected_prev[0];
	end
	if (
		( OUT_expected_prev[1] !== 1'bx ) && ( OUT_prev[1] !== OUT_expected_prev[1] )
		&& ((OUT_expected_prev[1] !== last_OUT_exp[1]) ||
			on_first_change[15])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port OUT[1] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", OUT_expected_prev);
		$display ("     Real value = %b", OUT_prev);
		nummismatches = nummismatches + 1;
		on_first_change[15] = 1'b0;
		last_OUT_exp[1] = OUT_expected_prev[1];
	end
	if (
		( OUT_expected_prev[2] !== 1'bx ) && ( OUT_prev[2] !== OUT_expected_prev[2] )
		&& ((OUT_expected_prev[2] !== last_OUT_exp[2]) ||
			on_first_change[15])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port OUT[2] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", OUT_expected_prev);
		$display ("     Real value = %b", OUT_prev);
		nummismatches = nummismatches + 1;
		on_first_change[15] = 1'b0;
		last_OUT_exp[2] = OUT_expected_prev[2];
	end
	if (
		( OUT_expected_prev[3] !== 1'bx ) && ( OUT_prev[3] !== OUT_expected_prev[3] )
		&& ((OUT_expected_prev[3] !== last_OUT_exp[3]) ||
			on_first_change[15])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port OUT[3] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", OUT_expected_prev);
		$display ("     Real value = %b", OUT_prev);
		nummismatches = nummismatches + 1;
		on_first_change[15] = 1'b0;
		last_OUT_exp[3] = OUT_expected_prev[3];
	end
	if (
		( OUT_expected_prev[4] !== 1'bx ) && ( OUT_prev[4] !== OUT_expected_prev[4] )
		&& ((OUT_expected_prev[4] !== last_OUT_exp[4]) ||
			on_first_change[15])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port OUT[4] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", OUT_expected_prev);
		$display ("     Real value = %b", OUT_prev);
		nummismatches = nummismatches + 1;
		on_first_change[15] = 1'b0;
		last_OUT_exp[4] = OUT_expected_prev[4];
	end
	if (
		( OUT_expected_prev[5] !== 1'bx ) && ( OUT_prev[5] !== OUT_expected_prev[5] )
		&& ((OUT_expected_prev[5] !== last_OUT_exp[5]) ||
			on_first_change[15])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port OUT[5] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", OUT_expected_prev);
		$display ("     Real value = %b", OUT_prev);
		nummismatches = nummismatches + 1;
		on_first_change[15] = 1'b0;
		last_OUT_exp[5] = OUT_expected_prev[5];
	end
	if (
		( OUT_expected_prev[6] !== 1'bx ) && ( OUT_prev[6] !== OUT_expected_prev[6] )
		&& ((OUT_expected_prev[6] !== last_OUT_exp[6]) ||
			on_first_change[15])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port OUT[6] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", OUT_expected_prev);
		$display ("     Real value = %b", OUT_prev);
		nummismatches = nummismatches + 1;
		on_first_change[15] = 1'b0;
		last_OUT_exp[6] = OUT_expected_prev[6];
	end
	if (
		( OUT_expected_prev[7] !== 1'bx ) && ( OUT_prev[7] !== OUT_expected_prev[7] )
		&& ((OUT_expected_prev[7] !== last_OUT_exp[7]) ||
			on_first_change[15])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port OUT[7] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", OUT_expected_prev);
		$display ("     Real value = %b", OUT_prev);
		nummismatches = nummismatches + 1;
		on_first_change[15] = 1'b0;
		last_OUT_exp[7] = OUT_expected_prev[7];
	end

	trigger <= ~trigger;
end
initial 

begin 
$timeformat(-12,3," ps",6);
#1000000;
if (nummismatches > 0)
	$display ("%d mismatched vectors : Simulation failed !",nummismatches);
else
	$display ("Simulation passed !");
$stop;
end 
endmodule

module TOP_vlg_vec_tst();
// constants                                           
// general purpose registers
reg [3:0] A;
reg [3:0] B;
reg CLK;
reg SEL;
// wires                                               
wire AA;
wire AB;
wire AC;
wire AD;
wire AE;
wire AF;
wire AG;
wire BA;
wire BB;
wire BC;
wire BD;
wire BE;
wire BF;
wire BG;
wire [7:0] OUT;

wire sampler;                             

// assign statements (if any)                          
TOP i1 (
// port map - connection between master ports and signals/registers   
	.A(A),
	.AA(AA),
	.AB(AB),
	.AC(AC),
	.AD(AD),
	.AE(AE),
	.AF(AF),
	.AG(AG),
	.B(B),
	.BA(BA),
	.BB(BB),
	.BC(BC),
	.BD(BD),
	.BE(BE),
	.BF(BF),
	.BG(BG),
	.CLK(CLK),
	.OUT(OUT),
	.SEL(SEL)
);
// A[ 3 ]
initial
begin
	A[3] = 1'b1;
end 
// A[ 2 ]
initial
begin
	A[2] = 1'b1;
end 
// A[ 1 ]
initial
begin
	A[1] = 1'b0;
end 
// A[ 0 ]
initial
begin
	A[0] = 1'b1;
end 
// B[ 3 ]
initial
begin
	B[3] = 1'b0;
end 
// B[ 2 ]
initial
begin
	B[2] = 1'b0;
end 
// B[ 1 ]
initial
begin
	B[1] = 1'b0;
end 
// B[ 0 ]
initial
begin
	B[0] = 1'b0;
end 

// CLK
initial
begin
	CLK = 1'b0;
end 

// SEL
initial
begin
	SEL = 1'b0;
end 

TOP_vlg_sample_tst tb_sample (
	.A(A),
	.B(B),
	.CLK(CLK),
	.SEL(SEL),
	.sampler_tx(sampler)
);

TOP_vlg_check_tst tb_out(
	.AA(AA),
	.AB(AB),
	.AC(AC),
	.AD(AD),
	.AE(AE),
	.AF(AF),
	.AG(AG),
	.BA(BA),
	.BB(BB),
	.BC(BC),
	.BD(BD),
	.BE(BE),
	.BF(BF),
	.BG(BG),
	.OUT(OUT),
	.sampler_rx(sampler)
);
endmodule

